\section{Related Work} 
\label{sec:relatedwork}

In the past, many algorithms have been proposed to mine subgraphs from a
given database of graphs. These algorithms can be mainly divided in to
two classes depending on how the candidate patterns are generated.
Algorithms like those in \cite{IWM03,FSG01,HWP03} are Apriori
based methods, i.e., a candidate pattern of size $k+1$ is generated by
combining two frequent graphs of size $k$ that have a common $k-1$ sized
subgraph.  Algorithms like those in \cite{gSpan,borgelt2002mmf,HWP03},
on the other hand, belong to the class of pattern growth algorithms in
which a candidate pattern is generated by extending a frequent pattern
with an edge. 

Mining subgraphs from a single graph is a related problem which is
surprisingly difficult compared to mining from a database of graphs.  In
\cite{kuramochi2005ffp}, they defined the support of a pattern
in a single graph as the maximum number of edge disjoint isomorphisms,
which is itself a $NP$-Hard problem.  In \cite{fiedler2007support}, they
proposed a definition of support based on overlapping ancestor
isomorphisms.  In \cite{2012-kais}, they proposed
CMDB-Miner\xspace to mine frequent patterns from a single large graph.
Support of a pattern is defined as the maximum flow in an appropriately
constructed flow network with capacities. This method estimates the
support of a pattern without enumerating its isomorphisms. The authors
also proposed methods to summarize the maximal frequent patterns
extracted from the graph. In \cite{li2010dessin}, they proposed an
algorithm to extract frequent patterns from dense graphs. It uses
$GADDI$ index proposed in \cite{Gaddi2009} to efficiently extract the
isomorphisms of a subgraph. 

There been little work in approximate subgraph
mining.  In \cite{gapprox}, they proposed $gApprox$ to mine approximate
frequent subgraphs.  The degree of approximation between a pattern and its
isomorphism includes label mismatches and missing edges. The search space
is explored in a depth first order and the support of a pattern is
computed by enumerating its isomorphisms. This approach is not feasible
for large graphs with label multiplicities as there are potentially
exponential number of isomorphisms \cite{2012-kais}.
In \cite{JiaZH11}, they proposed $APGM$ to approximate frequent
subgraphs from a database of graphs. The method is similar to the
$gApprox$ method in that it stores the complete set of approximate
embeddings of the current frequent pattern. The difference, however, is
that in \cite{JiaZH11} the entire $1$-hop neighborhood of the current
embeddings is explored to enumerate all extensions of the frequent
pattern and their corresponding embeddings, whereas $gApprox$ enumerates
the embeddings for a single extension in each step.  
In \cite{SpeedUpFAS}, the authors proposed strategies
to speed up the existing mining algorithms, by
limiting the number of candidates and also the number of duplicate
checks performed.
In \cite{RAM2008}, they proposed a randomized algorithm to mine
approximate patterns from a database graphs. In this method, an edge in
the approximate pattern is required to have at least a given number of
occurrences. 

Graph querying is another problem that is related to
subgraph mining. The goal is to find matches of a given query graph in a
single graph or database of graphs.  In \cite{TALE}, they proposed an
indexing method to extract the approximate occurrences of a given graph
query in large graph databases.  The algorithm proposed in
\cite{yan.icde:2006} extracts selective fragments from the query graph
and queries against an index constructed from the fragments of the
database graphs. In \cite{RandomMatching}, they proposed a polynomial
time algorithm for detecting isomorphism between spectrally
distinguishable graphs. An isomorphism, if it exists, 
is obtained by matching
the steady state vectors of Markov chains in both the graphs.  In
\cite{BerettiIndexing}, they proposed indexing and retrieval methods for
graph models. The problem with most of the indexing approaches is that
they are efficient in retrieving a single match for the query graph but
fail at retrieving all matches, and thus are not suited to mine frequent
patterns. Furthermore, they assume that the query given, and thus they
do not perform pattern enumeration as required in graph mining.

Frequent pattern mining algorithms usually return a large number of
patterns and interpreting them is a big challenge. This is especially
true if the output is presented to a human user for further analysis.
Sampling approaches like those proposed in
\cite{2009-graphsampling,2012-kais,RAM2008} mine a representative set of
maximal patterns from a database of graphs or a single graph. 
In our work, we perform a random walk in the search space
to enumerate a maximal pattern.

%The concept of using derived labels based on the
%structure and the attributes is frequently used in detecting graph
%isomorphism \cite{zampelli} and computing graph kernels
%\cite{shervashidzeJmlr,shervashidzeNips}. 
%Our methods to prune representative sets are somewhat similar to
%the wiesfieler lehman kernel to test isomorphism between two graphs
%$G_1$ and $G_2$ \cite{weisfeiler}, where after every iteration the labels are
%sorted and renamed with a different string in such a way that the pairwise
%relationship is maintained. $G_1$ is not isomorphic to $G_2$ 
%if the label set of the graphs differ. The specifics of how and what
%information we update is different, and also we use the information for
%subgraph isomorphism instead of graph isomorphism.

